

## 剑指Offer面试题: Python实现

第2章 面试基础知识
2.2 编程语言
面试题2 使用Python实现单例模式
2.3 数据结构
面试题3 二维数组中的查找

从右上角逐列递减，逐行递增

面试题4 替换空格

逆向遍历，并入栈，面试题5 从尾到头打印单链表

面试题6 重建二叉树
面试题7 用两个栈实现队列
2.4 算法和数据操作
面试题8 旋转数组的最小数字
面试题9 斐波那契数列

- 变态青蛙递推：

  ```
  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
  ```

  F(n)代表斐波那契数列第n项

  f(n)代表跳上n阶台阶需要多少步



 $f(0)=F(1) = 1$

$f(1)=f(0)=F(1)=F(2)=1$
$\begin{split}f(2)&=f(1)+f(0)\\&=2\cdot f(1)\end{split}$

$\begin{split}f(3)&=f(2)+f(1)+f(0)\\&=F(3)+F(2)+F(1)\\&=(F(2)+F(1))+F(2)+F(1)\\&=2\cdot(F(2)+F(1))\\&=2\cdot f(2)\end{split}$



$\begin{split}f(4)&=f(3)+f(2)+f(1)+f(0)\\&=f(3)+f(3)\\&=2\cdot f(3)\end{split}$

$f(n) = 2*f(n-1) \ ,n\ge2$







面试题10 二进制中1的个数
第3章 高质量代码
3.3 代码的完整性
面试题11 数值的整数次方
面试题12 打印1到最大的n位数
面试题13 O(1)时间删除链表结点
面试题14 调整数组顺序使寄数位于偶数前面
3.4 代码的鲁棒性
面试题15 链表中倒数第k个结点
面试题16 反转链表
面试题17 合并两个排序的链表
面试题18 树的子结构
第4章 解决面试题思路
4.2 画图让抽象问题形象化
面试题19 二叉树的镜像
面试题20 顺时针打印矩阵
4.3 举例让抽象问题具体化
面试题21 包含min函数的栈
面试题22 栈的压入弹出序列
面试题23 从上往下打印二叉树
面试题24 二叉树的后序遍历序列
面试题25 二叉树中和为某一值的路径
4.4 分解让复杂问题简单化
面试题26 复杂链表的复制
面试题27 二叉搜索树与双向链表
面试题28 字符串的排列
第5章 优化时间和空间效率
5.2 时间效率
面试题29 数组中出现次数超过一半的数字
面试题30 最小的k个数
面试题31 连续子数组的最大和
面试题32 从1到n整数中1出现的次数
面试题33 把数组排成最小的数
5.3 时间效率与空间效率的平衡
面试题34 丑数
面试题35 第一个只出现一次的字符
面试题36 数组中的逆序对
面试题37 两个链表的第一个公共结点
第6章 面试能力
6.3 知识迁移能力
面试题38 数字在排序数组中出现的次数
面试题39 二叉树的深度
面试题40 数组中只出现一次的数字
面试题41 和为s的两个数字VS和为s的连续正数序列
面试题42 翻转单词顺序与左旋转字符串
6.4 抽象建模能力
面试题43 n个骰子的点数
面试题44 扑克牌的顺子
面试题45 圆圈中最后剩下的数字
6.5 发散思维能力
面试题46 求1+2...+n
面试题47 不用加减乘除做加法
面试题48 不能被继承的类
第7章 面试案例
7.1 案例一
面试题49 把字符串转化成整数
7.2 案例二
面试题50 树中两个结点的最低公共祖先



## codejam

比实现代码更重要的是思考问题的方式以及如何构思将要采取的方案。

明确的知道你基本上可以解决问题比一昧的担心问题的一些细枝末节而迟迟不动手要有用的多。

发现问题的模式和策略

- [ ] 优先队列的实现方式

  - [ ] 数组，堆（斐波那契堆）

- [ ] 树

  - [ ] 堆
  - [x] 二叉搜索树（dfs前中后序遍历）\bfs
  - [ ] 二叉平衡树AVL
    1. 本身首先是一棵二叉搜索树
    2. 带有平衡条件：每个非叶子节点左右子树的高度之差的绝对值（平衡因子）最多为1.
  - [ ] 红黑树
    1. 节点是红色或黑色。
    2. 根是黑色。
    3. 所有叶子都是黑色（叶子是NIL节点）。
    4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
    5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

- [ ] 图

  基本定义：

  	连通图：图的任意两点之间都存在一条边

  - [ ] 存储结构

    - [ ] 邻接表
    - [ ] 邻接矩阵（邻接矩阵的性质）

  - [ ] 应用

    - [x] 最小生成树：无向有权图，是原图边的子集，边的权值总和最小

      寻找边的权值总和最小的连通子图

    - [x] 图的搜索及最短路径

      - [x] DFS
      - [x] BFS
      - [x] 正权重，单源顶点最短路径Dijkstra
      - [x] 含负权重但不含负环，单源顶点最短路径Bellman-For
      - [x] 任意两个顶点间最短路径FloydWarshall

二分查找，归并排序，快速排序

- [ ] 查找

  查找相对而言比较简单，不外乎顺序查找，二分查找，哈希表查找和二叉排序树查找。

- [ ] 排序

  稳定排序

  - [ ] 中值排序

应用：

利用图解决迷宫问题时，如何根据迷宫去构建图，更具体来说，如何从迷宫中确定顶点及边。





## 剑指offer2

2

2.4

- 重点掌握二分查找、归并排序和快速排序，做到随时正确、完整的写出代码，
- 如果面试要求在二维数组（可能表现为迷宫或者棋盘）上搜索路径，那么可以尝试回溯法。通常回溯法很适合递归代码实现。
- 如果是求某个问题的最优解，而且该问题可以分为多个子问题，那么我们可以尝试用动态规划。用自上而下的递归思路去分析动态规划问题的时候，会发现子问题之间存在重叠的更小的子问题。为了避免不必要的重复计算，我们用自下而上的循环代码来实现，也就是把子问题的最优解先算出来并用数组保存下来，接下来基于子问题的解计算大问题的解。
- 能得到最优解的那么往往要考虑贪婪算法





### 动态规划

动态规划实质上是一种优化技术，动态规划的思想为：建立详细的最优解表。先从简单的子问题开始。通过较小问题的最优解创建越来越大问题的最优解。

#### 动态规划和分治：

动态规划是分治范式的延伸，只有当问题具有明确限制和先决条件时，才能对问题采用动态规划方法。

这两个条件是：

- 问题的最优解由子问题的最优解构成
- 问题可以被分解为子问题，这些子问题可以重复使用或者可以使用递归算法解决而不会产生新的子问题

如果满足这两个限制，那么分治问题就可以采用动态规划的方法完成。

> 二分查找是一个典型的分治问题，但二分查找没有重叠子问题，不是动态规划问题。

动态规划的两种技术(**memoization** and **tabulation**) 

- memoization

  **Memoization (top-down cache filling)** refers to the technique of caching and reusing previously computed results

  ```python
  def fib(n, mem: dict):
      if n = 0 or n = 1:
          return n
      if n not in mem:
          mem[n] = fib(n - 1, mem) + fib(n - 2, mem)
      return mum[n]
  ```

- tabulation

  **Tabulation (bottom-up cache filling)** is similar but focuses on filling the entries of the cache. Computing the values in the cache is easiest done iteratively. 

  ```python
  def fib(n, mem: dict):
      mem[0] = 0
      mem[1] = 1
      for i in range(2, n+1):
          mem[i] = mem[i-1] + mem[i-2]
      return mem[n]
  ```

  缓存有效的原因是分治问题里有重叠的子问题

  二分查找没有重叠子问题，不是动态规划问题

#### 解决动态规划问题的步骤

> [参考](http://blog.refdash.com/dynamic-programming-tutorial-example/)

- 识别动态规划问题

- 确定问题变量

- 清楚的表达递归关系

  假定已经完成了 所有的子问题之后，如何解决主要的问题，

- 确定基案本例(base case)

  不依赖任何子问题的最小子问题

  确定这个问题之前，需要想清楚主要的问题是如何简化为更小的问题，以及在什么时候问题不能被进一步简化

  问题不能被简化的原因——其中一个参数由于问题的约束，变成了一个不可能的值，即确定边界条件

- 决定是要用迭代还是递归实现

- 添加缓存（自顶向下）

- 确定时间复杂度

  有一些简单的规则可以使计算动态编程问题的计算时间复杂性容易得多

#### 典型问题

通常我们会从斐波那契数列开始谈动态规划问题，但这次为了更深入的理解动态规划，我们来点不一样的，从最小编辑距离开始看吧。

- 最小编辑距离

  首先简单描述“编辑距离”，两个字符串，将a转化成b，采用插入、删除、和替换3种变换方式，最少的变化次数称为“编辑距离”，以下问题都是将a转化成b，且矩阵a的索引i作为行标，b的索引j作为列标，那么我们可以想象，一种操作次数最长的方式就是，从尾到头删除a，再从头到尾增加b。

  实际操作过程中，我们需要保存一个决策矩阵，矩阵元素的递推关系如下：

  ![](https://camo.githubusercontent.com/384008e2a31829248d01e4375399508555a2f900/68747470733a2f2f77696b696d656469612e6f72672f6170692f726573745f76312f6d656469612f6d6174682f72656e6465722f7376672f66306134386563666339383532633034323338326664633333633139653131613136393438653835)


$$
  
$$

- 斐波那契数列及其变体青蛙跳台阶问题

- 背包问题

**参考**

[Dynamic Programming: First Principles](http://www.flawlessrhetoric.com/Dynamic-Programming-First-Principles)

[利润最大化](https://lukasmericle.github.io/dynprotut/)





##### 递归和循环：

递归是在一个函数的内部调用这个函数自身，而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。递归虽然简洁，但是需要更多的时间和空间资源，因而效率不如循环；另外，递归的本质就是把一个问题分解成许多个小问题。如果多个小问题存在相互重叠的部分，就存在重复计算。



通常应用动态规划解决问题时，都是用递归的思路分析问题，但由于递归分解的子问题中存在大量的重复，因此我们总是用**自下而上**的**循环**来实现代码。



##### 查找和排序

查找相对而言比较简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。二分查找是必备知识点。



排序比查找要复杂一些，经常会要求比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，能够从额外空间消耗、平均时间复杂嘟和最差时间复杂嘟等比较有缺点。尤其对快速排序要特别精通



堆排序可视作提升的选择排序



### 树

> 一般指二叉树，由于树的结构特殊，所以基本树的算法都采用递归的方式实现，起始递归的实现方式只是分治思想的一种体现，因为关于树的很多问题其实都是可以相应的分解成类似的子问题。
>
> 如果子问题存在重复的计算过程，可以采用后序遍历的方式，自底向上的进行实现，例如判断一棵树是不是平衡的。
>
> 针对每一个递归问题的描述，作这样一个约定
>
> - 问题是如何分解成相同的一系列子问题
> - 递归结束条件

#### 树的表示

数组（list）

类

#### 树的遍历

深度优先

广度优先（从底向上逐层顺序输出树节点）

前中后序遍历的循环及递归算法实现

#### 平衡树

#### 二叉搜索树BST

> 二叉搜索树的中序遍历即对应顺序的数组

- 判断一棵树是否是二叉树

#### 线段树（segment tree)

是一棵完全二叉树

线段树应该支持的操作包括**updata**和**query**

- update

  更新输入数组中的某一个元素并对线段树做相应的改变。

  当输入数组中位于`i`位置的元素被更新时，我们只需从这一元素对应的叶子结点开始，沿二叉树的路径向上更新至更结点即可。显然，这一过程是一个`O(logn)`的操作。

- query

  用来查询某一区间对应的信息（如最大值，最小值，区间和等）



#### 树的应用

- 将二叉搜索树转换成一个排序的双向链表

  采用二叉树的中序遍历

- 最小(大)堆

- 寻找最小公共节点

- B树是不是A树的子结构

- 根据前序遍历和中序遍历序列重建二叉树

- 判断一棵树是不是平衡

  不仅要判断根节点是否平衡，还要判断子树本身是否平衡

- 判断一个序列是不是二叉搜索树的后序遍历序列

  思路：首先根据后序遍历的特性，序列的最后一个节点是当前树（或者子树）的根节点，根据根节点寻找到左子树和右子树序列（依据左子树序列的每一个元素都小于根节点，右子树序列的每一个元素都大于根节点，一旦原则上进入了右子树序列，出现比根节点小的元素，则可断定这不是后序遍历序列），对左右子树序列进行相同判断。（PS：递归停止条件在实现里描述）

  实现：定义起始指针left=0，确定左子序列，定义右子树序列指针right=left，如果当前序列只有一个节点，则会返回true，事实上除了根节点，是不会出现空序列进入递归，单元素序列会返回true，不会进一步递归。

  ```python
  def is_post_order(order: list):
       # 事实上除了最初序列为空，递归过程中不会出现空序列进入调用的情况，在单元素就会返回了，而且一定会返回True
      if order is None or len(order) == 0: 
          return False
      root = order[-1]
      left = 0
      # 如果只有一个元素的话，不会进入循环，因而不会出现数组越界，并且 left=0，right=left，返回true
      while order[left] < root:  
          left += 1
      right = left
      while right < len(order) - 1:
          if order[right] < root:
              return False
          right += 1
      is_left = True if left == 0 else is_post_order(order[:left])  # 左子序列为空, 因而left = 0，左子满足
      is_right = True if left == right else is_post_order(order[left: right])  # 右子树为空，因而right==left，右子满足
      return is_left and is_right
  ```

- 二叉树中和为某一值的所有路径

  > 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
  >
  > 在寻找所有路径的过程自然是要使用回溯的思想

  思路：首先判断该节点是不是叶节点，累加该节点的值，如果当前路径（该节点是叶节点）的累加和和预期值一致，那么保存该路径；如果不是叶节点，或者没有达到预期值，该节点还有左子和右子，那么继续递归访问左子和右子，访问结束后，回溯到该节点的父节点（回溯的具体操作为从累加和中去除该节点的值，从 当前“路径”【不是上面明确定义的路径，而是记录从根节点一路过来访问的所有节点】中去除该节点）。

  实现：参见下方

  ```python
  def find_path(bst_root, expected_sum):
      if bst_root is None:
          return
      path = []
      current_num = 0
      self._find_path(bst_root, expected_sum, path, current_num)
  
  def _find_path(bst_root, expected_sum, path, current_sum):
      is_leaf = bst_root.left is None and bst_root.right is None
      current_sum += bst_root.data
      path.append(bst_root.data)
      if current_sum == expected_sum and is_leaf:
          print(path[:])
  
      if bst_root.left is not None:
          _find_path(bst_root.left, expected_sum, path, current_sum)
      if bst_root.right is not None:
          _find_path(bst_root.right, expected_sum, path, current_sum)
  
      # cut current node from path and current value before returning to parent
      current_sum -= bst_root.data
      path.pop()
  ```


### 图

#### 如何用图思考

[原文](https://medium.freecodecamp.org/i-dont-understand-graph-theory-1c96572a1401)



#### 图的表示

邻接数组-静态图

邻接表-动态图

邻接矩阵

#### 图的遍历

> 相比广度优先使用队列存储未访问的邻接节点，深度遍历的循环实现方式使用栈存储当前节点的未访问邻接节点

##### 广度优先搜索

广度优先搜索从边上来说，都是从源点到图中任意顶点的最短路径的最短路径

##### 深度优先搜索

顶点访问顺序会改变计数器的值，所以需要注意临接节点的顺序，深度优先搜索计算出来的结果非常有用，包括**拓扑排序**，寻找**强连通部**，寻找网络中潜在的弱点。

深度优先搜索结束后，可以使用每个顶点存储的前序节点值找到一条从**任意顶点到原点s的路径**，当然，这条路径也许不是最短路径。

深度优先搜索仅仅依靠当前信息，是一种盲目的搜索，它没有一个明智的计划来快速达到目标顶点t。

##### 深度优先搜索的应用

###### 有向无环图中的拓扑排序

###### 有向图中计算强连通分量

##### 边的分类

根据在图G上进行深度优先搜索所产生的深度优先森林

- 树边(tree edge)
- 反向边(back edge)
- 正向边(forward edge)
- 交叉边(cross edge)



#### 最短路径

有向无环图

##### 单源最短路径

###### 非负边代价（Dijkstra）

###### 任意边代价（Bellman-Ford）

不可包含总权值为负值的环

##### 任意两个顶点间最短路径

动态规划Floyd-Warshall

#### 最小生成树

给定无向连通图$G=(V,E)$

#### 关于图的其他

- 欧拉回路(不重复经过所有边)和曼哈顿回路(不重复经过所有点)

- 



### 动态规划

- 最优二叉查找树

  - 包含n个健的二叉查找树的总数量等于第n个卡塔兰树
    $$
    当n>0时，c(n)=\cfrac{1}{n+1}[_n^{2n}],c(0)=1
    $$

    - 卡特兰数

      不能穿过对角线意味着任意时间向右的步数不能小于向左的步数，向右的步数记为左括号，向上的步数记为右括号

### 回溯

## 秣马厉兵

1. 假定图的邻接矩阵元素取值规则为：顶点之间存在边时对应元素值为1否则为0；下面关于图（顶点数大于1）的邻接矩阵描述正确的是

- 无向图的邻接矩阵对应特征值必然为非负数
- 无向图的邻接矩阵不一定可以对角化
- 有向无环图的邻接矩阵对应特征值必然为正数
- 无向完全图的邻接矩阵必然有大于0的特征值
- n顶点无向连通图对应邻接矩阵1的个数为2(n-1)则必然有环
- 以上描述都不正确

1. 对于矩阵的特征值和奇异值来说，以下说法正确的有
   - 奇异值分解只能作用于方针，而特征分解可以作用于任意矩阵
   - 特征分解只能作用于方阵，而奇艺值分解可以作用于任意矩阵
   - 奇异值分解和特征分解都可以作用于任意矩阵
   - 相比特征值，奇异值能更高效地压缩信息
   - 相比奇异值，特征值能更高效地压缩信息
   - 以上均不正确
2. 对数组[60,50,70,35,45,25]做从小到大排序（使用<堆排序>，建堆方式是从前往后建立最大堆例如[120，70，80，65]），从建堆到排序的过程中需要多少次元素交换？比如60，50，70，35，45，25->35,50,70,60,45,25,元素60和35交换记做一次元素交换

二元关联的相关度矩阵，连通图的最大生成子树，该子树的关联度加和



- [ ] 机器学习理解目标函数及变分推理blog
- [ ] 图和树算法，邻接矩阵的性质





20180906-算法引擎工程师

1. 提升处理器流水线并行度的方法有哪些
2. 从整个工程系统的角度，提升核心进程CPU分支预测准确率的方法有哪些
3. 在整体计算机体系中，有哪些带数据存储功能的单元？各自的数据访问时延是多少
4. c++程序中，变量会被分配在哪些区域？详细描述如何决定的？如何利用其提升程序性能？
5. 在软件工程体系中，进行分层设计的原因、目标与原则分别是什么？
6. 计算机体系结构中有哪些数据与指令cache
7. 河上有一个船，野人与传教士持续不定量到来，设计一个调度算法，要求每船4人，要么全是野人、要么全是传教士、要么数量相等。要求平均的等待+渡河时间越短越好
8. JVM的cms gc算法，是如何对内存进行压缩的
9. 如果让你来设计一个高性能、高稳定性的AI算法引擎，你会考虑哪些方面？会给系统设计哪些子模块？具体采用哪些技术点来实现
10. c++程序，如何减少开发阶段内存泄漏错误，如何排查与定位运行时内存泄漏错误。详述具体方法。
11. 纯手工实现一个函数，解析出淘宝搜索链接中的每一个元素，并作为一个完整结构体返回。函数传入的字符串可改。要求性能越高越好，不能调用第三方函数。
12. 有一个文本，2亿行，每行长度255个字符以内，长度不定，均为可见字符。在16core64G内存的机器上，对文件进行读入，排序（字典），输出成一个文件。要求完成整个工作的时间越短越好。



作者：慧大士

链接：https://www.zhihu.com/question/56029613/answer/147357122

来源：知乎

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

腾讯的数据挖掘或者说机器学习岗统称为基础研究，无论是bat还是其他的滴滴，今日头条，搜狗等等都需要大量数据挖掘岗，想要拿到offer，一般需要从两方面准备：

1  基础知识，涵盖两方面：基础数据结构算法，编程语言和数据库；机器学习主流算法原理及细节

1.1 基础数据结构算法，编程语言和数据库

 基础数据结构算法，这个没的说，要确保万无一失，需要掌握二叉树、链表、动态规划等等所有常考笔试面试题。

编程语言，无论平时用什么语言，c++和java必须掌握一个，需要能够使用常用的vector，map，set，queue，deque等等数据结构来解决一些常见面试编程题题。

数据库，数据库基本语法得会，我腾讯一面的时候直接上来就是用纸写一个sql的编程题，所以说常见sql编程题也必须会。

1.2 机器学习主流算法原理及细节

通过搜索往年的面经，可以发现机器学习或者数据挖掘面试常考的问题基本差不多，16年面试了百度，腾讯，滴滴，搜狗，蘑菇街等等公司，基本关于机器学习算法问的大同小异，从出现频率和重要程度排个序：

LR原理及公式推导，有哪些优化方法，梯度下降，牛顿法以及各种变种，L1、L2范数的区别，优缺点。（这个考的是最多的）

GBDT、XGBOOST原理异同，如何并行化等等（最好去xgboost官方看原始论文，讲得很清楚）

随机森林原理及细节。

如何解决数据不均衡问题。

SVM原理及细节，SVM和树模型的异同以及优缺点和局限性。

推荐系统，协同过滤原理，基于用户、物品等等。

深度学习中的一些小问题，比如relu是什么，如何解决梯度消失等等，这个最好了解下，毕竟深度学习这么火。

2 项目经历

项目这块，无论是数据挖掘竞赛还是一些项目，一定要自己把整个过程梳理一下，切记一问项目就是 ”提特征，跑模型，拿第一“，需要把项目的亮点体现出来，说白了就是你这个项目为什么牛逼，你做出了哪些厉害的贡献，这个需要技巧和准备。

其实这些企业再招聘的时候，如果你有不错的项目经历或者实习经历，是比较占优势的，毕竟面试时间就那么多，稍微聊一聊项目时间就消耗的差不多了，而且聊项目的时候主动权是在你的手里；但是如果你没有像样的项目，这就给了面试官提问的机会了，那就比较考验你的真正实力了。



## 计算机体系结构

### 计算机操作系统

1. 编译
   1. 编译和解释语言
   2. 静态类型
   3. 编译过程
   4. 目标代码
   5. 汇编代码
   6. 预处理
   7. 理解错误
2. 进程
   1. 抽象和虚拟化
   2. 隔离
   3. UNIX进程
3. 虚拟内存
   1. 简明信息理论
   2. 内存和存储
   3. 地址空间
   4. 内存段
   5. 静态局部变量
   6. 地址转换
4. 文件和文件系统
   1. 磁盘性能
   2. 磁盘元数据
   3. 块分配
   4. 一切都是一个文件？
5. 更多的位和字节
   1. 表示整数
   2. 位运算符
   3. 表示浮点型数
   4. 合并和内存错误
   5. 表示字符串
6. 内存管理
   1. 内存错误
   2. 内存泄露
   3. 实现
7. 缓存
   1. 程序如何运行
   2. 缓存性能
   3. 局部性
   4. 衡量缓存性能
   5. 缓存性能编程
   6. 内存层次结构
   7. 缓存策略
   8. 分页
8. 多任务
   1. 硬件状态
   2. 上下文转换
   3. 进程的生命周期
   4. 调度
   5. 实时调度
9. 线程
   1. 创建线程
   2. 同上
   3. 加入线程
   4. 同步错误
   5. 互斥
10. 条件变量
    1. 工作队列
    2. 生产者和消费者
    3. 互斥
    4. 条件变量
    5. 条件变量的实现
11. c中的信号量(Semaphores)
    1. POSIX信号量
    2. 生产者和消费者的信号量
    3. 创建自己的信号量



1. #### 编译

   1. ##### 编译和解释语言

   2. ##### 静态类型

      - “静态”指那些在编译时发生的事情，而“动态”指在运行时发生的事情。
      - 在编译语言中，变量的名称只存在于编译时，而不是运行时。编译器为每个变量选择一个位置，并记录这些位置作为所编译程序的一部分。变量的位置被称为“地址”。在运行期间，每个变量的值都储存在它的地址处，但是变量的名称完全不会储存（除非它们由于调试目的被编译器添加）

   3. ##### 编译过程

      - 预处理

      - 解析

        将程序读进内存中，构建语法树

      - 静态检查

        检查类型

      - 代码生成

      - 链接

      - 优化

   4. ##### 目标代码

      机器码

   5. ##### 汇编代码

      汇编代码——机器代码的可读形式

   6. ##### 预处理

   7. ##### 理解错误

      段错误——读写内存的不正确位置——

2. #### 进程

   1. ##### 抽象和虚拟化

      - 抽象

        抽象是复杂事物的简单表示

      - 虚拟化

        在虚拟化的语境中，我们通常把真实发生的事情叫做“物理的”，而把虚拟上发生的事情叫做“逻辑的”或者“抽象的”。

   2. ##### 隔离

      操作系统最重要的目标之一，就是将每个进程和其它进程隔离，使程序员不必考虑每个可能的交互情况。提供这种隔离的软件对象叫做进程（Process）。 

      进程是包含以下数据的对象：

      - 程序文本
      - 数据相关数据
      - 任何等待中的I/O状态
      - 程序的硬件状态

      进程和程序的关系

      - 通常一个进程运行一个程序，但是对于进程来说，加载并运行新的程序也是可能的。 
      - 多于一个进程中运行相同的程序，这非常常见。这种情况下，各个进程**共享程序文本**，但是**拥有不同的数据和硬件状态**。

   3. ##### UNIX进程

3. #### 虚拟内存

   1. ##### 简明信息理论

   2. ##### 内存和存储器

   3. ##### 地址空间

      - 主存中的每个字节都由一个“物理地址”整数所指定，物理地址的集合叫做物理“地址空间”。它的范围通常为0到`N-1`，其中`N`是主存的大小。
      - 虚拟内存

   4. ##### 内存段

   5. ##### 静态局部变量

   6. ##### 地址转换

4. #### 文件和文件系统

   1. ##### 磁盘性能

   2. ##### 磁盘元数据

   3. 块分配

      ##### 块分配

   4. ##### 一切都是一个文件？

5. #### 更多的位和字节

   1. ##### 表示整数

   2. ##### 位运算符

   3. ##### 表示浮点型数

   4. ##### 合并和内存错误

   5. ##### 表示字符串

6. #### 内存管理

   1. ##### 内存错误

   2. ##### 内存泄露

   3. ##### 实现

7. #### 缓存

   1. ##### 程序如何运行

   2. ##### 缓存性能

   3. ##### 局部性

   4. ##### 衡量缓存性能

   5. ##### 缓存性能编程

   6. ##### 内存层次结构

   7. ##### 缓存策略

   8. ##### 分页

8. #### 多任务

   1. ##### 硬件状态

   2. ##### 上下文转换

   3. ##### 进程的生命周期

   4. ##### 调度

   5. ##### 实时调度

9. #### 线程

   1. ##### 创建线程

   2. ##### 同上

   3. ##### 加入线程

   4. ##### 同步错误

   5. ##### 互斥

10. #### 条件变量

    1. ##### 工作队列

    2. ##### 生产者和消费者

    3. ##### 互斥

    4. ##### 条件变量

    5. ##### 条件变量的实现

11. #### c中的信号量(Semaphores)

    1. ##### POSIX信号量

    2. ##### 生产者和消费者的信号量

    3. ##### 创建自己的信号量

 

### 网络工程师们的计算机体系结构





| TCP                                                          | CPU                                                   |
| ------------------------------------------------------------ | ----------------------------------------------------- |
| TCP发送一连串的数据包                                        | CPU处理一系列指令                                     |
| TCP数据包最终被收到                                          | CPU指令最终会过期                                     |
| TCP会根据窗口大小发送一些列的几个数据包，而不会等待第一个数据包被接收后才行动 | CPU同时处理多个指令，而不是等待第一个指令执行完才行动 |
|                                                              | 指令引用没有缓存在内存地址时                          |
|                                                              |                                                       |
|                                                              |                                                       |
|                                                              |                                                       |
|                                                              |                                                       |
|                                                              |                                                       |

### 计算机组成原理

存储程序概念是冯·诺依曼等人在1946年6月首先提出来的，它可以简要地概括为以下 几点: 

1. 计算机(指硬件)应由运算器、存储器、控制器、输入设备和输出设备五大基本部 件组成; 

2. 计算机内部采用二进制来表示指令和数据;

3. 将编好的程序和原始数据事先存入存储器中，然后再启动计算机工作，这就是存储程序的基本含义。

![](/media/files/images/sc_51.png)

- 运算器和控制器合称为中央处理器CPU

- 中央处理器和主存储器（内存储器）一起组成主机部分

- 三级存储系统

  - 高速缓冲存储器

    存取速度比主存更快，但是容量更小

  - 主存储器

  - 辅助存储器

  三级系统可再划分为两个层次：

  - Cache存储系统

    高速缓存和主存

  - 虚拟存储系统

    主存和辅村

- 计算机执行过程实例

  ![](/media/files/images/sc_52.png)


### 内容分发网络（CDN）

内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。

### 应用层

#### 微服务

可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。



微服务中的关键技术挑战

- 服务间通信
  - http
  - 异步消息
- 分布式数据管理



缓存-遗漏，乱序执行，流水线执行





### 常用linux指令

### Python中的一些语法细节

#### 注意事项

- **永远不要使用小数比较结果来作为两者相等的判断依据**

  可以采取`abs(a-b) < 1e-7`作为二者相等的判断

- 



## 构建数据密集型应用(Designing Data-Intensive Application)



**第一部分：数据系统的基石**

讨论设计数据密集型应用所依赖的基本思想

- 第一章：可靠性、可扩展性、可维护性

  - 讨论我们实际要到达的目标：可靠性(Reliability)，可扩展型(Scalability)，可维护性(Maintainability)；
  - 我们该如何思考这些概念；
  - 以及如何实现他们

- 第二章：数据模型与查询语言

  比较不同的数据模型和查询语言，看看他们如何适用于不同的场景

- 第三章：存储与检索

  讨论存储引擎：数据库如何在磁盘上摆放数据，以及如何高效地再次找到它

- 第四章：编码与演化

  数据编码（序列化），以及随时间演化的模式。

**第二部分：分布式数据**

讨论存储在一台机器上的数据转向讨论分布在多台机器上的数据，这对于可扩展性是必须的，但带来各种独特的挑战

- 第五章：复制

- 第六章：分区

- 第七章：事务

- 第八章：分布式系统的麻烦

  探索关于分布式系统的更多细节

- 第九章：一致性与共识

  分布式系统中实现一致性与共识意味着什么
**第三部分：衍生数据**

讨论那些从其他数据集衍生出一些数据集的系统。衍生数据经常出现在异构系统中：当没有单个数据库可以把所有事情都做的很好时，应用需要集成几种不同的数据库，缓存，索引等。

- 第十章：批处理

- 第十一章：流处理

- 第十二章：数据系统的未来

  讨论在将来构建可靠，可伸缩和可维护的应用程序



### 第一部分：数据系统的基石

讨论设计数据密集型应用所依赖的基本思想

#### 第一章：可靠性、可扩展性、可维护性

数据密集型应用通常由标准组件构成，标准组件提供了很多通用功能：

- 数据库

- 消息队列

- 缓存

- 搜索索引

- 流处理

- 批处理

  ![](/media/files/images/sc_45.png)

- ##### 可靠性

- ##### 可扩展性

  ###### 负载

  推特业务为例

  - 发布推文

    ![](/media/files/images/sc_46.png)

  - 主页时间线

    ![](/media/files/images/sc_47.png)

  **在早期创业公司或非正式产品中，通常支持产品快速迭代的能力要比可扩展至未来的假想负载要重要的多。**

- 可维护性

  - 可操作性（Operability）
  - 简单性(Simplicity)
  - 可演化性(Evolability)

#### 第二章：数据模型与查询语言

比较不同的数据模型和查询语言，看看他们如何适用于不同的场景

- 关系数据库与文档数据库对比

  当存在多对多关系时，需要在应用程序代码中模拟连接，这通常会比数据库内的专用代码执行的连接慢。

**数据查询语言**

- web上的声明式查询

  在web浏览器中，使用声明式css样式比使用js命令式的操作样式要好的多，类似地，在数据库中，使用sql这样的声明式查询语言比使用命令式查询api要好。

- mapreduce查询

  mapreduce在分布上查询上并不具有垄断

  编程模型

- 图数据模型

#### 第三章：存储与检索

讨论存储引擎：数据库如何在磁盘上摆放数据，以及如何高效地再次找到它

事务性负载和分析性负载（列存储）

两大类存储引擎：

- 日志结构(log-structured)
- 面向页面(page-oriented)

##### 驱动数据库的数据结构

- 哈希索引

- SSTables（Sorted String Table） and LSM-Trees

- BTree

  比上面3者更为常用

- 事务处理和分析系统

  ![](/media/files/images/sc_48.png)

- 数据仓库

  数据仓库包含公司所有各种OLTP系统中的只读数据副本。从OLTP数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中。

  将数据存入仓库的过程称为“抽取-转换-加载”(ETL)

- OLTP数据库和数据仓库之间的分歧

![](/media/files/images/sc_49.png)

- 星型和雪花型：分析的模式

  星型：![](/media/files/images/sc_50.png)

- 列存储

  Parquet【57】

  Vertical【62】

  OLTP数据库和文档数据库存储都是以面向行的形式进行布局

  >Cassandra和HBase从Bigtable继承，仍然是面向行的

  - 写入列存储

#### 第四章：编码与演化

数据编码（序列化），以及随时间演化的模式。

几种编码数据的格式，包括JSON，XML，Protocol Buffers，Thrift和Avro，以及这些格式如何应对模式变化，及利用这些格式进行数据存储和通信：REST，RPC（Remote Procedure Call，远程过程调用）以及消息传递系统（actors和消息队列）。

使用某种语言的内置编码通常不是一个好主意。

- 向前和向后兼容性

##### 数据如何在流程之间流动的一些最常见的方式

- 数据库中的数据流

  微服务架构：一个关键的设计目标就是通过使服务独立部署和演化来使应用程序更易于更改和维护。

- web service
  - REST，SOAP
  - RPC
  - 异步消息传递

### 第二部分：分布式数据

讨论存储在一台机器上的数据转向讨论分布在多台机器上的数据，这对于可扩展性是必须的，但带来各种独特的挑战

#### 第五章：复制

同步不同的复制数据间的更改

- 处理节点宕机
  - 从库失效：追赶恢复
  - 主库失效：故障转移

#### 第六章：分区

![](/media/files/images/sc_60.png)



#### 第七章：事务

#### 第八章：分布式系统的麻烦

探索关于分布式系统的更多细节

#### 第九章：一致性与共识

分布式系统中实现一致性与共识意味着什么

### 第三部分：衍生数据

讨论那些从其他数据集衍生出一些数据集的系统。衍生数据经常出现在异构系统中：当没有单个数据库可以把所有事情都做的很好时，应用需要集成几种不同的数据库，缓存，索引等。

#### 第十章：批处理

#### 第十一章：流处理

#### 第十二章：数据系统的未来

讨论在将来构建可靠，可伸缩和可维护的应用程序

 